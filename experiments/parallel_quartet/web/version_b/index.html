<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Version B — Rift Relay Tactical Loop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* === Systems-Forward Prototype === */
    /* Coordination Note: Grid sizing + solver logic share assumptions. Update both when scaling. */
    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(160deg, #050608 0%, #0d1022 60%, #161d36 100%);
      color: #e6f0ff;
      font-family: "JetBrains Mono", "Fira Mono", monospace;
      display: grid;
      place-items: center;
      padding: 1.5rem;
      box-sizing: border-box;
    }

    main {
      display: grid;
      gap: 1.5rem;
      width: min(960px, 95vw);
    }

    header {
      border: 1px solid rgba(104, 162, 255, 0.3);
      border-radius: 18px;
      padding: 1.25rem;
      background: rgba(10, 15, 32, 0.65);
      box-shadow: 0 18px 40px rgba(4, 7, 18, 0.55);
    }

    h1 {
      margin: 0 0 0.25rem;
      font-size: clamp(1.6rem, 3.6vw, 2.3rem);
      letter-spacing: 0.08em;
    }

    p {
      margin: 0.3rem 0;
      line-height: 1.55;
      color: rgba(222, 234, 255, 0.8);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      aspect-ratio: 1;
      border: 1px solid rgba(104, 162, 255, 0.35);
      border-radius: 22px;
      overflow: hidden;
      position: relative;
      background: rgba(8, 12, 24, 0.65);
      box-shadow: inset 0 0 48px rgba(0, 0, 0, 0.5);
    }

    button.node {
      appearance: none;
      border: none;
      margin: 0;
      background: transparent;
      position: relative;
      color: inherit;
      cursor: pointer;
      transition: background 180ms ease, transform 180ms ease;
      font: inherit;
      display: grid;
      place-items: center;
    }

    button.node::before {
      content: "";
      width: 74%;
      height: 74%;
      border-radius: 16px;
      border: 1px solid rgba(120, 160, 255, 0.28);
      background: rgba(10, 16, 32, 0.6);
      transition: inherit;
      box-shadow: 0 0 22px rgba(40, 90, 255, 0.12);
    }

    button.node span {
      position: relative;
      z-index: 1;
      font-size: 1.05rem;
      letter-spacing: 0.04em;
      opacity: 0.75;
    }

    button.node.active::before {
      background: radial-gradient(circle at 35% 35%, rgba(88, 144, 255, 0.8), rgba(16, 32, 88, 0.9));
      border-color: rgba(152, 208, 255, 0.8);
      box-shadow: 0 0 32px rgba(88, 144, 255, 0.5);
    }

    button.node.route::before {
      background: linear-gradient(135deg, rgba(52, 255, 208, 0.85), rgba(60, 140, 255, 0.65));
      border-color: rgba(112, 252, 232, 0.9);
      transform: translateY(-2px);
      box-shadow: 0 0 36px rgba(94, 226, 255, 0.5);
    }

    .status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      font-size: 0.95rem;
      color: rgba(220, 232, 255, 0.7);
    }

    .status span {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .status button {
      background: rgba(34, 68, 158, 0.8);
      border: none;
      color: white;
      padding: 0.6rem 1.1rem;
      border-radius: 999px;
      font: inherit;
      cursor: pointer;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      box-shadow: 0 6px 18px rgba(34, 68, 158, 0.4);
    }

    .status button:hover {
      background: rgba(42, 92, 214, 0.85);
    }
  </style>
</head>
<body>
  <!-- Context: Version B tests tactical resonance puzzles for systems-heavy players. -->
  <main>
    <header>
      <h1>Rift Relay — Tactical Harmonics</h1>
      <p>Prime relay nodes so an energy pulse can cross fractured terrain. Each activation shifts adjacent charge, forcing foresight.</p>
      <p><strong>Prototype Goal:</strong> Validate single-screen loop for deckbuilder/strategy audiences.</p>
      <p><em>Controls:</em> Click nodes to toggle them. Hit "Propagate" to send the energy wave.</p>
    </header>

    <section class="grid" aria-label="Relay puzzle grid"></section>

    <div class="status">
      <span id="status-text">Awaiting configuration...</span>
      <button id="propagate">Propagate</button>
    </div>
  </main>

  <script>
    // === Energy Propagation Logic ===
    // Shared State: 5x5 grid, central core auto-active.
    const GRID_SIZE = 5;
    const CORE_INDEX = Math.floor(GRID_SIZE * GRID_SIZE / 2);

    const gridElement = document.querySelector('.grid');
    const statusText = document.getElementById('status-text');
    const propagateButton = document.getElementById('propagate');

    const nodes = Array.from({ length: GRID_SIZE * GRID_SIZE }, (_, idx) => ({
      index: idx,
      active: idx === CORE_INDEX,
      route: false
    }));

    // Build grid UI once.
    nodes.forEach(node => {
      const button = document.createElement('button');
      button.className = 'node' + (node.active ? ' active' : '');
      button.dataset.index = node.index;
      button.innerHTML = `<span>${node.index === CORE_INDEX ? 'CORE' : node.index + 1}</span>`;
      button.addEventListener('click', () => toggleNode(node.index));
      node.element = button;
      gridElement.appendChild(button);
    });

    function toggleNode(index) {
      if (index === CORE_INDEX) return; // Core remains stable.
      const node = nodes[index];
      node.active = !node.active;
      node.element.classList.toggle('active', node.active);
      node.element.classList.remove('route');
      statusText.textContent = 'Configuration updated. Awaiting propagation.';
    }

    function indexToCoord(index) {
      return { x: index % GRID_SIZE, y: Math.floor(index / GRID_SIZE) };
    }

    function neighbors(index) {
      const { x, y } = indexToCoord(index);
      const coords = [
        { x: x + 1, y },
        { x: x - 1, y },
        { x, y: y + 1 },
        { x, y: y - 1 }
      ];
      return coords
        .filter(({ x, y }) => x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE)
        .map(({ x, y }) => y * GRID_SIZE + x);
    }

    function propagate() {
      nodes.forEach(node => node.route = false);
      const frontier = [CORE_INDEX];
      const visited = new Set(frontier);
      nodes[CORE_INDEX].route = true;

      while (frontier.length > 0) {
        const current = frontier.shift();
        for (const neighbor of neighbors(current)) {
          const node = nodes[neighbor];
          if (node.active && !visited.has(neighbor)) {
            visited.add(neighbor);
            frontier.push(neighbor);
            node.route = true;
          }
        }
      }

      nodes.forEach(node => {
        node.element.classList.toggle('route', node.route);
      });

      const routedCount = nodes.filter(n => n.route).length;
      const coverage = Math.round((routedCount / nodes.length) * 100);

      if (coverage === 100) {
        statusText.textContent = 'Full resonance achieved. Rift sealed!';
      } else if (coverage > 55) {
        statusText.textContent = `Partial harmony (${coverage}%). Adjust fringe nodes for full seal.`;
      } else {
        statusText.textContent = `Signal collapsed at ${coverage}%. Re-route energy flow.`;
      }
    }

    propagateButton.addEventListener('click', propagate);

    // Auto-propagate on first load to demonstrate behavior.
    propagate();
  </script>
</body>
</html>
