<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Version D — Verdant Circuit Simulation</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* === Systems Garden Prototype === */
    /* Collaboration Signal: Growth rules defined in evolve() for quick experimentation. */
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 20%, #071a12, #020904 75%);
      color: #d9ffe7;
      font-family: "Space Grotesk", sans-serif;
      display: grid;
      place-items: center;
      padding: clamp(1.5rem, 5vw, 3rem);
      box-sizing: border-box;
    }

    main {
      width: min(980px, 95vw);
      display: grid;
      gap: 1.5rem;
      background: rgba(8, 28, 18, 0.7);
      border-radius: 24px;
      border: 1px solid rgba(88, 214, 155, 0.32);
      box-shadow: 0 24px 60px rgba(1, 15, 9, 0.65);
      padding: clamp(1.5rem, 5vw, 3rem);
    }

    header h1 {
      margin: 0 0 0.25rem;
      font-size: clamp(1.7rem, 4.2vw, 2.6rem);
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    header p {
      margin: 0.35rem 0;
      line-height: 1.6;
      color: rgba(217, 255, 231, 0.78);
    }

    canvas {
      width: 100%;
      height: clamp(360px, 55vh, 520px);
      border-radius: 18px;
      border: 1px solid rgba(92, 224, 171, 0.38);
      background: rgba(0, 10, 4, 0.7);
      box-shadow: inset 0 0 40px rgba(0, 0, 0, 0.6);
      cursor: crosshair;
    }

    .controls {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      color: rgba(210, 255, 225, 0.72);
      font-size: 0.95rem;
    }

    .controls button {
      background: rgba(42, 148, 102, 0.85);
      border: none;
      color: #f4fff8;
      padding: 0.6rem 1.15rem;
      border-radius: 999px;
      font: inherit;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow: 0 12px 24px rgba(42, 148, 102, 0.35);
    }

    .controls button:hover {
      background: rgba(58, 188, 128, 0.9);
    }

    .legend {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      font-size: 0.85rem;
      color: rgba(205, 255, 224, 0.7);
    }

    .swatch {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }

    .color-chip {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.45);
    }
  </style>
</head>
<body>
  <!-- Context: Version D is a sandbox systems loop tuned for streamer-friendly chill sessions. -->
  <main>
    <header>
      <h1>Verdant Circuit — Eco Resonance</h1>
      <p>Lure symbiotic spores into balance. Drop seeds, coax flow, and keep the reactor singing without tipping the ecology.</p>
      <p><strong>Prototype Goal:</strong> Stress-test lightweight systemic growth for web builds.</p>
    </header>

    <canvas id="field" width="600" height="600" aria-label="Growth field"></canvas>

    <div class="controls">
      <span id="status">Cycle: 0 — Equilibrium nominal.</span>
      <div>
        <button id="pulse">Pulse</button>
        <button id="clear">Clear</button>
      </div>
    </div>

    <div class="legend">
      <span class="swatch"><span class="color-chip" style="background:#5ce6a6"></span> Healthy canopy</span>
      <span class="swatch"><span class="color-chip" style="background:#ffe97a"></span> Overcharged bloom</span>
      <span class="swatch"><span class="color-chip" style="background:#ff7a9e"></span> Fading biome</span>
    </div>
  </main>

  <script>
    // === Growth Simulation ===
    // Collaboration Hook: Colors + thresholds defined in CONFIG for tuning.
    const canvas = document.getElementById('field');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const pulseButton = document.getElementById('pulse');
    const clearButton = document.getElementById('clear');

    const CONFIG = {
      cols: 48,
      rows: 48,
      birthThreshold: 0.52,
      overchargeThreshold: 0.78,
      fadeThreshold: 0.22,
      diffusion: 0.14,
      decay: 0.93
    };

    const cellWidth = canvas.width / CONFIG.cols;
    const cellHeight = canvas.height / CONFIG.rows;

    let grid = new Float32Array(CONFIG.cols * CONFIG.rows);
    let cycle = 0;
    let animationFrame;

    function index(x, y) {
      return y * CONFIG.cols + x;
    }

    function seed(x, y, amount = 1) {
      const rad = 2;
      for (let dx = -rad; dx <= rad; dx++) {
        for (let dy = -rad; dy <= rad; dy++) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= CONFIG.cols || ny >= CONFIG.rows) continue;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance <= rad + Math.random() * 0.3) {
            grid[index(nx, ny)] = Math.min(1, grid[index(nx, ny)] + amount * (1 - distance / (rad + 0.001)));
          }
        }
      }
    }

    function evolve() {
      // Growth rule: diffuse to neighbors, apply decay, then clamp thresholds.
      const next = new Float32Array(grid.length);
      for (let x = 0; x < CONFIG.cols; x++) {
        for (let y = 0; y < CONFIG.rows; y++) {
          const idx = index(x, y);
          const value = grid[idx];

          let sum = 0;
          let count = 0;
          for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
              if (dx === 0 && dy === 0) continue;
              const nx = x + dx;
              const ny = y + dy;
              if (nx < 0 || ny < 0 || nx >= CONFIG.cols || ny >= CONFIG.rows) continue;
              sum += grid[index(nx, ny)];
              count++;
            }
          }

          const average = count > 0 ? sum / count : 0;
          let updated = value * CONFIG.decay + average * CONFIG.diffusion;

          if (updated > CONFIG.overchargeThreshold) {
            updated *= 0.82; // bleed excess energy
          } else if (updated < CONFIG.fadeThreshold) {
            updated *= 0.92; // accelerate fade to encourage reseeding
          } else if (average > CONFIG.birthThreshold) {
            updated += 0.08; // encourage cluster bloom
          }

          next[idx] = Math.max(0, Math.min(1, updated));
        }
      }

      grid = next;
      cycle += 1;
      render();
    }

    function render() {
      for (let x = 0; x < CONFIG.cols; x++) {
        for (let y = 0; y < CONFIG.rows; y++) {
          const value = grid[index(x, y)];
          const hue = value < CONFIG.fadeThreshold
            ? { color: '#2b0b18' }
            : value > CONFIG.overchargeThreshold
            ? { color: '#ffe97a' }
            : { color: '#5ce6a6' };
          ctx.fillStyle = hue.color;
          ctx.globalAlpha = Math.min(0.15 + value * 0.85, 1);
          ctx.fillRect(x * cellWidth, y * cellHeight, cellWidth + 1, cellHeight + 1);
        }
      }

      ctx.globalAlpha = 1;
      status.textContent = `Cycle: ${cycle} — ${evaluateHealth()}`;
    }

    function evaluateHealth() {
      const total = grid.length;
      let healthy = 0;
      let fading = 0;
      let over = 0;
      for (const value of grid) {
        if (value > CONFIG.overchargeThreshold) over++;
        else if (value < CONFIG.fadeThreshold) fading++;
        else healthy++;
      }

      if (over / total > 0.35) return 'Warning: Overcharge cascade forming.';
      if (fading / total > 0.4) return 'Warning: Biome drift detected.';
      if (healthy / total > 0.55) return 'Equilibrium nominal.';
      return 'Balancing...';
    }

    function loop() {
      evolve();
      animationFrame = requestAnimationFrame(loop);
    }

    function start() {
      cancelAnimationFrame(animationFrame);
      animationFrame = requestAnimationFrame(loop);
    }

    function stop() {
      cancelAnimationFrame(animationFrame);
    }

    canvas.addEventListener('pointerdown', evt => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor(((evt.clientX - rect.left) / rect.width) * CONFIG.cols);
      const y = Math.floor(((evt.clientY - rect.top) / rect.height) * CONFIG.rows);
      seed(x, y, 1);
      render();
    });

    pulseButton.addEventListener('click', () => {
      evolve();
    });

    clearButton.addEventListener('click', () => {
      grid = new Float32Array(CONFIG.cols * CONFIG.rows);
      cycle = 0;
      render();
    });

    // Auto-seed starter cluster for quick evaluation.
    seed(CONFIG.cols / 2, CONFIG.rows / 2, 1);
    seed(CONFIG.cols / 2 - 5, CONFIG.rows / 2 + 3, 0.8);
    seed(CONFIG.cols / 2 + 4, CONFIG.rows / 2 - 4, 0.9);
    render();
    start();

    // Pause simulation when document hidden to save resources.
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stop();
      } else {
        start();
      }
    });
  </script>
</body>
</html>
